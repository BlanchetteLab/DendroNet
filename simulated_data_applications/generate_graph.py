import numpy as np


class GridNode:
    def __init__(self, features, factors):
        self.features = features
        self.factors = factors
        self.y = self.generate_y()
        self.height = None

    def generate_y(self):
        result = 0.0
        for i in range(len(self.factors)):
            result += (self.features[i]) * self.factors[i]
        return result


def gen_random_grid(size, mutation_rate=0.1, num_factors=3, seed=0):
    """
    Main point: factors are determined by their top and left neighbours, plus some random mutation of their own
    :param size:
    :param mutation_rate:
    :param num_factors:
    :param seed:
    :return:
    """

    np.random.seed(seed)
    curr_a = np.random.uniform(size=num_factors)
    curr_x = np.random.normal(loc=0.0, scale=1.0, size=num_factors)
    curr_x[-1] = 1.0  # this is the bias feature

    node_list = []
    x_list = []
    y_list = []
    edge_matrix = np.zeros(shape=(size*size, size*size), dtype=np.int)

    grid = [[None for _ in range(size)] for _ in range(size)]
    """
    Fill the root (upper left), and then progress one row at a time,
    averaging between left and upper neighbours (if present)
    """

    for row in range(size):
        for col in range(size):
            if row == col == 0:
                # generate the root
                root_node = GridNode(features=curr_x, factors=curr_a)  # y value gets generated by the class
                grid[0][0] = root_node
                node_list.append(root_node)
                x_list.append(root_node.features)
                y_list.append(root_node.y)
            else:
                curr_x = np.random.normal(loc=0.0, scale=1.0, size=num_factors)
                if row == 0:
                    curr_a = np.asarray(grid[0][col-1].factors)
                    edge_matrix[len(node_list)][node_list.index(grid[0][col-1])] = 1.0  # row child col parent
                elif col == 0:
                    curr_a = np.asarray(grid[row-1][0].factors)
                    edge_matrix[len(node_list)][node_list.index(grid[row-1][0])] = 1
                else:
                    curr_a = (grid[row-1][col].factors + grid[row][col-1].factors) / 2.0
                    edge_matrix[len(node_list)][node_list.index(grid[0][col - 1])] = 1
                    edge_matrix[len(node_list)][node_list.index(grid[row - 1][0])] = 1
                # add mutation
                for i in range(len(curr_a)):
                    mutation_delta = np.random.exponential(scale=mutation_rate)
                    # exponential gives only positive values, need to flip half of them negative
                    if np.random.uniform() < 0.5:
                        mutation_delta *= -1.0
                    curr_a[i] = curr_a[i] + mutation_delta

                grid[row][col] = GridNode(features=curr_x, factors=curr_a)
                node_list.append(grid[row][col])
                x_list.append(grid[row][col].features)
                y_list.append(grid[row][col].y)

    return np.transpose(np.asarray(edge_matrix)), x_list, y_list
